import os from 'os';

// 延迟加载 node-pty，避免导入时崩溃
let pty = null;
const loadPty = async () => {
  if (!pty) {
    pty = await import('node-pty');
  }
  return pty;
};

export class LocalShellManager {
  constructor(shellType = 'powershell') {
    this.shellType = shellType;
    this.ptyProcess = null;
    this.connected = false;
    this.terminalBuffer = [];
    this.maxBufferLines = 1000;
  }

  async connect(onData) {
    return new Promise(async (resolve, reject) => {
      try {
        // 加载 node-pty
        const ptyModule = await loadPty();
        
        let shell, shellArgs;
        
        if (os.platform() === 'win32') {
          if (this.shellType === 'powershell') {
            // 默认使用 Windows PowerShell
            shell = 'powershell.exe';
            shellArgs = ['-NoLogo'];
          } else if (this.shellType === 'cmd') {
            shell = 'cmd.exe';
            shellArgs = [];
          } else {
            shell = 'powershell.exe';
            shellArgs = ['-NoLogo'];
          }
        } else {
          // Linux/Mac
          shell = process.env.SHELL || '/bin/bash';
          shellArgs = [];
        }

        // 创建 PTY 进程
        this.ptyProcess = ptyModule.spawn(shell, shellArgs, {
          name: 'xterm-256color',
          cols: 80,
          rows: 24,
          cwd: process.env.HOME || process.env.USERPROFILE || process.cwd(),
          env: process.env,
          // Windows 特定选项
          useConpty: os.platform() === 'win32',
          conptyInheritCursor: os.platform() === 'win32'
        });

        // 监听数据输出
        this.ptyProcess.onData((data) => {
          this.addToBuffer(data);
          onData(data);
        });

        // 监听进程退出
        this.ptyProcess.onExit(({ exitCode, signal }) => {
          console.log(`Shell process exited with code ${exitCode}, signal ${signal}`);
          this.connected = false;
        });

        this.connected = true;
        console.log(`Local shell (${this.shellType}) started successfully`);
        resolve();
      } catch (error) {
        console.error('Failed to start shell:', error);
        this.connected = false;
        reject(error);
      }
    });
  }

  write(data) {
    if (this.ptyProcess && this.connected) {
      try {
        this.ptyProcess.write(data);
      } catch (error) {
        console.error('Error writing to PTY:', error);
      }
    }
  }

  resize(cols, rows) {
    if (this.ptyProcess && this.connected) {
      try {
        this.ptyProcess.resize(cols, rows);
      } catch (error) {
        console.error('Error resizing PTY:', error);
      }
    }
  }

  disconnect() {
    if (this.ptyProcess) {
      try {
        this.ptyProcess.kill();
      } catch (error) {
        console.error('Error killing PTY process:', error);
      }
    }
    this.connected = false;
  }

  isConnected() {
    return this.connected;
  }

  addToBuffer(text) {
    const lines = text.split('\n');
    this.terminalBuffer.push(...lines);
    
    if (this.terminalBuffer.length > this.maxBufferLines) {
      this.terminalBuffer = this.terminalBuffer.slice(-this.maxBufferLines);
    }
  }

  getBufferContent(lines = 100) {
    const start = Math.max(0, this.terminalBuffer.length - lines);
    return this.terminalBuffer.slice(start).join('\n');
  }

  async executeCommand(command, timeout = 30000) {
    return new Promise((resolve, reject) => {
      if (!this.connected) {
        reject(new Error('Not connected to shell'));
        return;
      }

      let output = '';
      const timeoutId = setTimeout(() => {
        dataDisposable?.dispose();
        reject(new Error('Command execution timeout'));
      }, timeout);

      // 监听数据输出
      const dataDisposable = this.ptyProcess.onData((data) => {
        output += data;
      });

      // 发送命令
      this.write(command + '\r');

      // 等待命令执行完成
      setTimeout(() => {
        clearTimeout(timeoutId);
        dataDisposable.dispose();
        
        resolve({
          exitCode: 0,
          output: output
        });
      }, 2000); // 等待 2 秒收集输出
    });
  }
}